var PredictChart=function(t){function n(i){if(e[i])return e[i].exports;var r=e[i]={exports:{},id:i,loaded:!1};return t[i].call(r.exports,r,r.exports,n),r.loaded=!0,r.exports}var e={};return n.m=t,n.c=e,n.p="",n(0)}([function(module,exports,__webpack_require__){eval("'use strict';\n\nvar str2number = __webpack_require__(5);\nvar scaleLinear = __webpack_require__(4);\nvar UnitUtil = __webpack_require__(10);\nvar Raphel = __webpack_require__(6);\nvar predictPercent = 0.7; // 预测部分偏移量\nvar ChartPrototype = __webpack_require__(7);\nvar createPathString = __webpack_require__(2);\nvar objectAssign = __webpack_require__(8);\n\nvar _require = __webpack_require__(1),\n    OUTTER_MARGIN = _require.OUTTER_MARGIN,\n    VOL_HEIGHT = _require.VOL_HEIGHT,\n    BOTTOM_TEXT_HEIGHT = _require.BOTTOM_TEXT_HEIGHT,\n    PIXEL_FIX = _require.PIXEL_FIX,\n    STROKE_COLOR = _require.STROKE_COLOR,\n    DASH_COLOR = _require.DASH_COLOR,\n    FONT_SIZE = _require.FONT_SIZE,\n    TEXT_COLOR = _require.TEXT_COLOR,\n    TEXT_MARGIN = _require.TEXT_MARGIN;\n\nvar px = __webpack_require__(3);\n\nvar PredictChart = function PredictChart(container, _ref) {\n\tvar chartWidth = _ref.chartWidth,\n\t    chartHeight = _ref.chartHeight,\n\t    candleData = _ref.candleData,\n\t    predictData = _ref.predictData,\n\t    needVolume = _ref.needVolume,\n\t    ticksY = _ref.ticksY,\n\t    tooltip = _ref.tooltip,\n\t    yAxisFormater = _ref.yAxisFormater;\n\n\tthis.container = container;\n\tthis.paper = new Raphel(container, chartWidth, chartHeight);\n\tthis.chartWidth = chartWidth;\n\tthis.chartHeight = chartHeight;\n\n\tthis.candleData = candleData.map(str2number);\n\tthis.predictData = predictData.map(str2number);\n\tthis.needVolume = needVolume;\n\tthis.ticksY = ticksY;\n\n\tthis.options = {\n\t\ttooltip: tooltip,\n\t\tyAxisFormater: yAxisFormater\n\t};\n};\n\nPredictChart.prototype = {\n\tdraw: function draw() {\n\t\tvar _this = this;\n\n\t\tvar candleData = this.candleData,\n\t\t    predictData = this.predictData;\n\n\t\tvar all = candleData.concat(predictData);\n\n\t\tvar low = all.reduce(function (prev, curr) {\n\t\t\tif (curr.low < prev) {\n\t\t\t\treturn curr.low;\n\t\t\t}\n\n\t\t\treturn prev;\n\t\t}, all[0].low);\n\n\t\tvar high = all.reduce(function (prev, curr) {\n\t\t\tif (curr.high > prev) {\n\t\t\t\treturn curr.high;\n\t\t\t}\n\n\t\t\treturn prev;\n\t\t}, all[0].high);\n\n\t\tif (this.options.yAxisFormater) {\n\t\t\tthis.low = this.options.yAxisFormater(low);\n\t\t\tthis.high = this.options.yAxisFormater(high);\n\t\t} else {\n\t\t\tthis.low = low.toFixed(2);\n\t\t\tthis.high = high.toFixed(2);\n\t\t}\n\n\t\tvar maxVol = candleData.reduce(function (prev, curr) {\n\t\t\treturn Math.max(curr.volume, prev);\n\t\t}, candleData[0].volume);\n\n\t\t// 测量宽度\n\t\tvar maxVolDisplay = UnitUtil.million(maxVol);\n\t\tvar widest;\n\n\t\tif (encodeURI(maxVolDisplay).length > encodeURI(this.high).length) {\n\t\t\twidest = maxVolDisplay;\n\t\t} else {\n\t\t\twidest = this.high;\n\t\t}\n\n\t\tvar tempText = this.paper.text(0, 0, widest);\n\t\tvar bbox = tempText.getBBox();\n\t\tthis.yAxisTextWidth = bbox.width;\n\t\ttempText.remove();\n\n\t\tvar yAxisTextWidth = this.yAxisTextWidth;\n\t\tthis.width = this.chartWidth - yAxisTextWidth - TEXT_MARGIN; // 总宽度减y轴文字宽度\n\n\t\tif (this.needVolume) {\n\t\t\tthis.height = this.chartHeight - VOL_HEIGHT - FONT_SIZE - TEXT_MARGIN * 2; // 总高度减量柱高度减x轴文字高度\n\t\t} else {\n\t\t\tthis.height = this.chartHeight - FONT_SIZE - TEXT_MARGIN;\n\t\t}\n\n\t\tthis.paper.rect(px(0), px(0), this.width, this.height).attr({\n\t\t\tstroke: STROKE_COLOR\n\t\t});\n\n\t\t// 预测部分图形的偏移量\n\t\tthis.offset = this.width * predictPercent;\n\n\t\tvar yScale = scaleLinear().domain([0, this.ticksY - 1]).rangeRound([0, this.height]);\n\n\t\t// 预测部分半透明虚框\n\t\tvar pathString = createPathString({\n\t\t\tx: this.offset,\n\t\t\ty: 0\n\t\t}, {\n\t\t\tx: this.width,\n\t\t\ty: 0\n\t\t}, {\n\t\t\tx: this.width,\n\t\t\ty: this.height\n\t\t}, {\n\t\t\tx: this.offset,\n\t\t\ty: this.height\n\t\t});\n\n\t\tthis.paper.path(pathString).attr({\n\t\t\t'fill': '#e7f2fc',\n\t\t\t'stroke-width': 0,\n\t\t\t'fill-opacity': 0.6\n\t\t});\n\n\t\t// 虚框左侧虚线\n\t\tvar x1 = px(this.offset);\n\t\tvar y1 = px(0);\n\t\tvar x2 = px(this.offset);\n\t\tvar y2 = void 0;\n\t\tif (this.needVolume) {\n\t\t\ty2 = px(this.height + VOL_HEIGHT + FONT_SIZE + TEXT_MARGIN * 2);\n\t\t} else {\n\t\t\ty2 = px(this.height);\n\t\t}\n\n\t\tthis.paper.path(createPathString({\n\t\t\tx: x1,\n\t\t\ty: y1\n\t\t}, {\n\t\t\tx: x2,\n\t\t\ty: y2\n\t\t})).attr({\n\t\t\tstroke: DASH_COLOR,\n\t\t\t\"stroke-dasharray\": '- '\n\t\t});\n\n\t\t// y轴文字信息\n\t\tvar priceScale = scaleLinear().domain([0, this.ticksY - 1]).range([low, high]);\n\n\t\tfor (var i = 0; i < this.ticksY; i++) {\n\t\t\tvar x = this.width;\n\t\t\tvar y = yScale(i);\n\t\t\tvar txt = priceScale(i);\n\n\t\t\tif (this.options.yAxisFormater) {\n\t\t\t\ttxt = this.options.yAxisFormater(txt);\n\t\t\t} else {\n\t\t\t\ttxt = Number(txt).toFixed(2);\n\t\t\t}\n\n\t\t\tvar elem = this.paper.text(x, y, txt).attr('fill', '#999');\n\t\t\tvar box = elem.getBBox();\n\t\t\tvar width = box.width,\n\t\t\t    height = box.height;\n\n\n\t\t\tconsole.log('txt:', txt, width);\n\n\t\t\tx = x + (width >> 1) + TEXT_MARGIN;\n\n\t\t\ty = i === 0 ? this.height - y - height / 2 : this.height - y + height / 2;\n\n\t\t\telem.attr({\n\t\t\t\tx: x,\n\t\t\t\ty: y\n\t\t\t});\n\t\t}\n\n\t\t// x轴文字信息\n\t\tvar dates = [candleData[0].time, candleData[candleData.length - 1].time, predictData[predictData.length - 1].time];\n\n\t\tdates.forEach(function (item, index, arr) {\n\t\t\tvar elem = _this.paper.text(0, 0, item).attr('fill', '#999');\n\t\t\tvar box = elem.getBBox();\n\t\t\tvar width = box.width,\n\t\t\t    height = box.height;\n\n\n\t\t\tvar x;\n\t\t\tvar y = _this.height + height / 2 + TEXT_MARGIN;\n\n\t\t\tif (index === 0) {\n\t\t\t\tx = 0 + width / 2;\n\t\t\t} else if (index === 1) {\n\t\t\t\tx = _this.offset - width / 2;\n\t\t\t} else {\n\t\t\t\tx = _this.width - width / 2;\n\n\t\t\t\tif (width > _this.width - _this.offset) {\n\t\t\t\t\tx = _this.width;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telem.attr({\n\t\t\t\tx: x,\n\t\t\t\ty: y\n\t\t\t});\n\t\t});\n\n\t\t// 横向辅助线\n\t\tthis.drawHelperLines(yScale);\n\t\tthis.drawCandles(this.offset);\n\t\tthis.drawPredictWave();\n\n\t\t// 量线\n\t\tif (this.needVolume) {\n\t\t\tthis.drawVolumes();\n\t\t}\n\n\t\t// 事件\n\t\tif (this.options.tooltip) {\n\t\t\tthis.createEventLayer();\n\t\t}\n\t},\n\t// 画预测图\n\tdrawPredictWave: function drawPredictWave() {\n\t\tvar candleData = this.candleData,\n\t\t    predictData = this.predictData;\n\n\n\t\tvar color1 = '#80b5ff';\n\t\tvar color2 = '#e63232';\n\t\tvar linearP = scaleLinear().domain([0, predictData.length]).rangeRound([this.offset, this.width]);\n\t\tvar linearY = this.candleY;\n\t\tvar upString = [];\n\t\tvar midString = [];\n\t\tvar downString = [];\n\t\tvar lastCandle = candleData[candleData.length - 1];\n\n\t\tpredictData.unshift({\n\t\t\tlow: lastCandle.close,\n\t\t\thigh: lastCandle.close,\n\t\t\tclose: lastCandle.close\n\t\t});\n\n\t\tthis.predictCloseYList = [];\n\t\tthis.predictXList = [];\n\n\t\tfor (var i = 0; i < predictData.length; i++) {\n\t\t\tvar predictX = linearP(i);\n\n\t\t\tupString.push({\n\t\t\t\tx: predictX,\n\t\t\t\ty: linearY(predictData[i].high)\n\t\t\t});\n\n\t\t\tmidString.push({\n\t\t\t\tx: predictX,\n\t\t\t\ty: linearY(predictData[i].close)\n\t\t\t});\n\n\t\t\tthis.predictCloseYList.push(linearY(predictData[i].close));\n\n\t\t\tdownString.push({\n\t\t\t\tx: predictX,\n\t\t\t\ty: linearY(predictData[i].low)\n\t\t\t});\n\n\t\t\tthis.predictXList.push(predictX);\n\t\t}\n\n\t\t// console.log(upString, midString, downString)\n\t\tthis.paper.path(createPathString.apply(undefined, upString)).attr('stroke', color1);\n\t\tthis.paper.path(createPathString.apply(undefined, midString)).attr('stroke', color2);\n\t\tthis.paper.path(createPathString.apply(undefined, downString)).attr('stroke', color1);\n\n\t\t// 预测部分虚线参考线开始位置再实际k线最后一根收盘处\n\t\tvar y = linearY(lastCandle.close);\n\t\tvar str = createPathString({\n\t\t\tx: linearP(0),\n\t\t\ty: y\n\t\t}, {\n\t\t\tx: this.width,\n\t\t\ty: y\n\t\t});\n\n\t\tthis.paper.path(str).attr({\n\t\t\tstroke: DASH_COLOR,\n\t\t\t\"stroke-dasharray\": '- '\n\t\t});\n\t}\n};\n\nobjectAssign(PredictChart.prototype, ChartPrototype);\n\nmodule.exports = PredictChart;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/PredictChart.js\n// module id = 0\n// module chunks = 0\n//# sourceURL=webpack:///./src/PredictChart.js?")},function(module,exports){eval("'use strict';\n\nvar MARGIN_TABLE = {\n\t10: 4,\n\t20: 3,\n\t40: 1,\n\t60: 1\n};\n\nvar PIXEL_FIX = 0.5;\nvar OUTTER_MARGIN = 2;\nvar VOL_HEIGHT = 66;\nvar FONT_SIZE = 12;\nvar WIN_COLOR = '#e63232';\nvar LOSS_COLOR = '#55a500';\nvar EQUAL_COLOR = '#999999';\nvar STROKE_COLOR = '#d8d8d8';\nvar DASH_COLOR = '#999999';\nvar BOTTOM_TEXT_HEIGHT = 20;\nvar TEXT_COLOR = '#0287fe';\nvar TEXT_MARGIN = 10;\n\nmodule.exports = {\n\tMARGIN_TABLE: MARGIN_TABLE,\n\tOUTTER_MARGIN: OUTTER_MARGIN,\n\tVOL_HEIGHT: VOL_HEIGHT,\n\tFONT_SIZE: FONT_SIZE,\n\tPIXEL_FIX: PIXEL_FIX,\n\tWIN_COLOR: WIN_COLOR,\n\tLOSS_COLOR: LOSS_COLOR,\n\tSTROKE_COLOR: STROKE_COLOR,\n\tDASH_COLOR: DASH_COLOR,\n\tBOTTOM_TEXT_HEIGHT: BOTTOM_TEXT_HEIGHT,\n\tTEXT_COLOR: TEXT_COLOR,\n\tTEXT_MARGIN: TEXT_MARGIN,\n\tEQUAL_COLOR: EQUAL_COLOR\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/libs/config.js\n// module id = 1\n// module chunks = 0 1\n//# sourceURL=webpack:///./src/libs/config.js?")},function(module,exports){eval('"use strict";\n\nvar createPathString = function createPathString() {\n\tfor (var _len = arguments.length, points = Array(_len), _key = 0; _key < _len; _key++) {\n\t\tpoints[_key] = arguments[_key];\n\t}\n\n\tvar pathString = "M" + points[0].x + "," + points[0].y;\n\n\tfor (var i = 1; i < points.length; i++) {\n\t\tpathString += "L" + points[i].x + "," + points[i].y;\n\t}\n\n\treturn pathString;\n};\n\nmodule.exports = createPathString;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/libs/createPathString.js\n// module id = 2\n// module chunks = 0 1\n//# sourceURL=webpack:///./src/libs/createPathString.js?')},function(module,exports){eval('"use strict";\n\nvar pixelFix = 0.5;\n\nvar px = function px(value) {\n\tvalue = Math.floor(value);\n\treturn value + pixelFix;\n};\n\nmodule.exports = px;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/libs/px.js\n// module id = 3\n// module chunks = 0 1\n//# sourceURL=webpack:///./src/libs/px.js?')},function(module,exports){eval("\"use strict\";\n\nvar scaleLinear = function scaleLinear() {\n  var min, max;\n\n  var normalize = function normalize(x) {\n    return (x - min) / (max - min);\n  };\n\n  var domain = function domain(arr) {\n    min = arr[0];\n    max = arr[arr.length - 1];\n\n    return this;\n  };\n\n  var range = function range(arr) {\n    var a = arr[0];\n    var b = arr[arr.length - 1];\n\n    a = +a;\n    b -= a;\n\n    return function (x) {\n      return a + b * normalize(x);\n    };\n  };\n\n  var rangeRound = function rangeRound(arr) {\n    var a = arr[0];\n    var b = arr[arr.length - 1];\n\n    a = +a;\n    b -= a;\n\n    return function (x) {\n      return Math.round(a + b * normalize(x));\n    };\n  };\n\n  return {\n    domain: domain,\n    range: range,\n    rangeRound: rangeRound\n  };\n};\n\n// const scaleLinear = require('d3-scale').scaleLinear\n\nmodule.exports = scaleLinear;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/libs/scaleLinear.js\n// module id = 4\n// module chunks = 0 1\n//# sourceURL=webpack:///./src/libs/scaleLinear.js?")},function(module,exports){eval("'use strict';\n\nmodule.exports = function (stock) {\n\tvar keys = ['low', 'high', 'open', 'close'];\n\n\tkeys.forEach(function (key) {\n\t\tstock[key] = Number(stock[key]);\n\t});\n\n\treturn stock;\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/libs/str2number.js\n// module id = 5\n// module chunks = 0 1\n//# sourceURL=webpack:///./src/libs/str2number.js?")},function(module,exports){eval('module.exports = window.Raphael;\n\n//////////////////\n// WEBPACK FOOTER\n// external "window.Raphael"\n// module id = 6\n// module chunks = 0 1\n//# sourceURL=webpack:///external_%22window.Raphael%22?')},function(module,exports,__webpack_require__){eval("'use strict';\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar scaleLinear = __webpack_require__(4);\nvar $ = __webpack_require__(9);\nvar Raphel = __webpack_require__(6);\nvar str2number = __webpack_require__(5);\nvar UnitUtil = __webpack_require__(10);\n\nvar _require = __webpack_require__(1),\n    OUTTER_MARGIN = _require.OUTTER_MARGIN,\n    VOL_HEIGHT = _require.VOL_HEIGHT,\n    FONT_SIZE = _require.FONT_SIZE,\n    STROKE_COLOR = _require.STROKE_COLOR,\n    WIN_COLOR = _require.WIN_COLOR,\n    LOSS_COLOR = _require.LOSS_COLOR,\n    EQUAL_COLOR = _require.EQUAL_COLOR,\n    TEXT_MARGIN = _require.TEXT_MARGIN;\n\nvar px = __webpack_require__(3);\nvar createPathString = __webpack_require__(2);\n\nvar ChartPrototype = {\n\tdrawBasic: function drawBasic() {},\n\tdrawHelperLines: function drawHelperLines(yScale) {\n\t\t// K线横向辅助线\n\t\tfor (var i = 1; i < this.ticksY - 1; i++) {\n\t\t\tvar x1 = px(0);\n\t\t\tvar y1 = px(this.height - yScale(i));\n\t\t\tvar x2 = px(this.width);\n\t\t\tvar y2 = px(this.height - yScale(i));\n\n\t\t\t// console.log(x1, y1, x2, y2)\n\n\t\t\tvar pathString = createPathString({ x: x1, y: y1 }, { x: x2, y: y2 });\n\n\t\t\tthis.paper.path(pathString).attr({\n\t\t\t\tstroke: STROKE_COLOR\n\t\t\t});\n\t\t}\n\t},\n\tdrawCandles: function drawCandles(baseWidth) {\n\t\tvar _this = this;\n\n\t\tvar round = Math.round;\n\t\tvar candleData = this.candleData,\n\t\t    predictData = this.predictData,\n\t\t    low = this.low,\n\t\t    high = this.high;\n\n\t\tvar scaleY = scaleLinear().domain([low, high]).rangeRound([this.height, 0]);\n\t\tvar totalWidth = baseWidth - OUTTER_MARGIN * 2;\n\t\tvar count = candleData.length;\n\t\tvar candleWidth = 2 * totalWidth / (3 * count - 1);\n\t\tvar candleSpace = candleWidth / 2;\n\n\t\tif (candleSpace < 1) {\n\t\t\tcandleSpace = 0;\n\t\t\tcandleWidth = totalWidth / count;\n\t\t}\n\n\t\t// console.log('candleWidth, candleSpace', candleWidth, candleSpace)\n\t\tthis.closeYList = [];\n\t\tthis.shadowXList = [];\n\t\tthis.paper.setStart();\n\n\t\tcandleData.forEach(function (item, index) {\n\t\t\tvar open = item.open,\n\t\t\t    close = item.close,\n\t\t\t    low = item.low,\n\t\t\t    high = item.high;\n\n\t\t\tvar x = OUTTER_MARGIN + round(index * (candleWidth + candleSpace));\n\t\t\tvar y1 = void 0,\n\t\t\t    y2 = void 0,\n\t\t\t    color = void 0,\n\t\t\t    height = void 0;\n\n\t\t\tif (open > close) {\n\t\t\t\ty1 = scaleY(open);\n\t\t\t\ty2 = scaleY(close);\n\n\t\t\t\tcolor = LOSS_COLOR;\n\t\t\t} else if (open < close) {\n\t\t\t\ty1 = scaleY(close);\n\t\t\t\ty2 = scaleY(open);\n\n\t\t\t\tcolor = WIN_COLOR;\n\t\t\t} else {\n\t\t\t\ty1 = y2 = scaleY(open);\n\t\t\t\tcolor = EQUAL_COLOR;\n\t\t\t}\n\n\t\t\theight = Math.abs(y1 - y2);\n\n\t\t\tif (height < 1) {\n\t\t\t\theight = 1;\n\t\t\t}\n\n\t\t\t// console.log('蜡烛块信息:', px(x), px(y1), candleWidth, height)\n\n\t\t\t_this.closeYList.push(y1);\n\n\t\t\t// 实体块\n\t\t\t_this.paper.rect(x, y1, candleWidth, height).attr({\n\t\t\t\t'fill': color,\n\t\t\t\t'stroke-width': 0\n\t\t\t});\n\n\t\t\t// 上下影线\n\t\t\tvar shadowX = px(x + round(candleWidth / 2));\n\t\t\tvar pathString = createPathString({\n\t\t\t\tx: shadowX,\n\t\t\t\ty: px(scaleY(high))\n\t\t\t}, {\n\t\t\t\tx: shadowX,\n\t\t\t\ty: px(scaleY(low))\n\t\t\t});\n\n\t\t\t_this.shadowXList.push(shadowX);\n\t\t\t_this.paper.path(pathString).attr('stroke', color);\n\t\t});\n\n\t\tthis.candleWidth = candleWidth;\n\t\tthis.candleSpace = candleSpace;\n\t\tthis.candleY = scaleY;\n\n\t\tthis.candleSet = this.paper.setFinish();\n\n\t\tthis.drawPolyline();\n\t\tthis.hidePolySet();\n\t},\n\tdrawVolumes: function drawVolumes() {\n\t\tvar _this2 = this;\n\n\t\tvar round = Math.round;\n\t\t// 量线，绘制量柱\n\t\tvar volX = 0;\n\t\tvar volY = this.height + FONT_SIZE + TEXT_MARGIN * 2; // 加文字高度\n\t\tvar volWidth = this.width;\n\t\tvar volHeight = VOL_HEIGHT;\n\t\tvar candleData = this.candleData;\n\t\tvar candleWidth = this.candleWidth,\n\t\t    candleSpace = this.candleSpace;\n\n\t\t// 量图边框\n\n\t\tthis.paper.rect(px(volX), px(volY), volWidth, volHeight - 1).attr('stroke', STROKE_COLOR);\n\n\t\tvar maxVol = candleData.reduce(function (prev, curr) {\n\t\t\treturn Math.max(curr.volume, prev);\n\t\t}, candleData[0].volume);\n\t\tvar minVol = candleData.reduce(function (prev, curr) {\n\t\t\treturn Math.min(curr.volume, prev);\n\t\t}, candleData[0].volume);\n\t\tvar volScale = scaleLinear().domain([minVol, maxVol]).rangeRound([0, volHeight]);\n\n\t\t// 量柱横向辅助线\n\t\tvar helperLineY = this.height + FONT_SIZE + TEXT_MARGIN * 2 + (volHeight >> 1);\n\t\tvar p1 = {\n\t\t\tx: px(0),\n\t\t\ty: px(helperLineY)\n\t\t};\n\t\tvar p2 = {\n\t\t\tx: px(this.width),\n\t\t\ty: px(helperLineY)\n\t\t};\n\t\tthis.paper.path(createPathString(p1, p2)).attr({\n\t\t\tstroke: STROKE_COLOR\n\t\t});\n\n\t\tvar arr = [minVol, (maxVol + minVol) / 2, maxVol];\n\t\tvar offsetY = this.height + TEXT_MARGIN * 2 + FONT_SIZE;\n\t\tvar paper = this.paper;\n\t\tfor (var i = 0; i < 3; i++) {\n\t\t\tvar txt = paper.text(0, 0, UnitUtil.million(arr[i])).attr('fill', '#999999');\n\t\t\tvar box = txt.getBBox();\n\t\t\tvar x = this.width + TEXT_MARGIN + box.width / 2;\n\t\t\tvar y = offsetY + volHeight - volHeight / 2 * i;\n\n\t\t\tif (i === 0) {\n\t\t\t\ty -= box.height / 2;\n\t\t\t} else if (i === 2) {\n\t\t\t\ty += box.height / 2;\n\t\t\t}\n\n\t\t\ttxt.attr({\n\t\t\t\tx: x,\n\t\t\t\ty: y\n\t\t\t});\n\t\t}\n\n\t\t// 量柱\n\t\tcandleData.forEach(function (item, index, arr) {\n\t\t\tvar x = OUTTER_MARGIN + round(index * (candleWidth + candleSpace));\n\t\t\tvar h = volScale(item.volume);\n\t\t\tvar y = _this2.height + FONT_SIZE + TEXT_MARGIN * 2 + volHeight - h;\n\t\t\tvar open = item.open,\n\t\t\t    close = item.close;\n\n\t\t\tvar color = void 0;\n\n\t\t\tif (open > close) {\n\t\t\t\tcolor = LOSS_COLOR;\n\t\t\t} else if (open < close) {\n\t\t\t\tcolor = WIN_COLOR;\n\t\t\t} else {\n\t\t\t\tcolor = EQUAL_COLOR;\n\t\t\t}\n\n\t\t\t_this2.paper.rect(x, y, candleWidth, h).attr({\n\t\t\t\tfill: color,\n\t\t\t\t'stroke-width': 0\n\t\t\t});\n\t\t});\n\n\t\treturn true;\n\t},\n\tcreateTooltip: function createTooltip() {\n\t\tvar tooltip = $('<div>').css({\n\t\t\tposition: 'absolute',\n\t\t\ttop: 10\n\t\t});\n\n\t\tif (this.options.tooltip.className) {\n\t\t\ttooltip.addClass(this.options.tooltip.className);\n\t\t}\n\n\t\treturn tooltip;\n\t},\n\tgetTooltipHtml: function getTooltipHtml(data, index) {\n\t\tvar fn = this.options.tooltip.fn;\n\t\tvar html = '';\n\n\t\tif (fn) {\n\t\t\thtml = fn(data, index);\n\t\t}\n\n\t\treturn html;\n\t},\n\tcreateEventLayerNormal: function createEventLayerNormal() {\n\t\tvar _this3 = this;\n\n\t\tvar elem = $('<div>').css({\n\t\t\tposition: 'absolute',\n\t\t\tleft: 0,\n\t\t\ttop: 0,\n\t\t\twidth: this.chartWidth,\n\t\t\theight: this.chartHeight\n\t\t});\n\n\t\t$(this.container).css({\n\t\t\tposition: 'relative'\n\t\t}).append(elem);\n\n\t\tvar offset = elem.offset();\n\t\tvar paper = new Raphel(elem[0], this.chartWidth, this.chartHeight);\n\t\tvar scaleLeft;\n\t\tvar floatLine;\n\t\tvar tooltip;\n\n\t\tvar line = function line(x, y) {\n\t\t\tif (!floatLine) {\n\t\t\t\tfloatLine = paper.path(createPathString({\n\t\t\t\t\tx: px(x),\n\t\t\t\t\ty: px(0)\n\t\t\t\t}, {\n\t\t\t\t\tx: px(x),\n\t\t\t\t\ty: px(y)\n\t\t\t\t})).attr({\n\t\t\t\t\tstroke: STROKE_COLOR\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfloatLine.attr({\n\t\t\t\tpath: createPathString({\n\t\t\t\t\tx: px(x),\n\t\t\t\t\ty: px(0)\n\t\t\t\t}, {\n\t\t\t\t\tx: px(x),\n\t\t\t\t\ty: px(y)\n\t\t\t\t}),\n\t\t\t\tstroke: STROKE_COLOR\n\t\t\t});\n\t\t};\n\n\t\telem.on('mouseenter', function (e) {\n\t\t\tif (scaleLeft === undefined) {\n\t\t\t\tscaleLeft = scaleLinear().domain([0, _this3.width]).rangeRound([0, _this3.shadowXList.length - 1]);\n\t\t\t}\n\n\t\t\tif (tooltip === undefined) {\n\t\t\t\ttooltip = _this3.createTooltip();\n\n\t\t\t\t_this3.eventLayer.append(tooltip);\n\t\t\t}\n\t\t});\n\n\t\telem.on('mousemove', function (e) {\n\t\t\tif (_this3.shadowXList === undefined) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar x = e.pageX - offset.left;\n\t\t\tvar index = scaleLeft(x);\n\t\t\tvar x = _this3.shadowXList[index];\n\t\t\tvar item;\n\t\t\tvar top;\n\n\t\t\tif (x === undefined) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar y = _this3.needVolume ? _this3.height + FONT_SIZE + VOL_HEIGHT : _this3.height;\n\t\t\tline(x, y);\n\n\t\t\titem = _this3.candleData[index];\n\t\t\ttop = _this3.closeYList[index];\n\n\t\t\tif (x >= _this3.width - tooltip.width()) {\n\t\t\t\ttooltip.css({\n\t\t\t\t\t'top': top,\n\t\t\t\t\t'left': '',\n\t\t\t\t\t'right': _this3.chartWidth - _this3.width + 5\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\ttooltip.css({\n\t\t\t\t\t'top': top,\n\t\t\t\t\t'left': x + 5,\n\t\t\t\t\t'right': ''\n\t\t\t\t});\n\t\t\t}\n\n\t\t\ttooltip.html(_this3.getTooltipHtml(item, index));\n\t\t});\n\n\t\telem.on('mouseleave', function (e) {\n\t\t\tscaleLeft = undefined;\n\t\t\tfloatLine = undefined;\n\t\t\tpaper.clear();\n\t\t\ttooltip.remove();\n\t\t\ttooltip = undefined;\n\t\t});\n\n\t\tthis.eventLayer = elem;\n\t},\n\tcreateEventLayer: function createEventLayer() {\n\t\tvar _this4 = this;\n\n\t\tvar layerWidth = this.chartWidth - this.yAxisTextWidth;\n\t\tvar elem = $('<div>').css({\n\t\t\tposition: 'absolute',\n\t\t\tleft: 0,\n\t\t\ttop: 0,\n\t\t\twidth: layerWidth,\n\t\t\theight: this.chartHeight\n\t\t});\n\n\t\t$(this.container).css({\n\t\t\tposition: 'relative'\n\t\t}).append(elem);\n\n\t\tvar offset = elem.offset();\n\t\tvar paper = new Raphel(elem[0], layerWidth, this.chartHeight);\n\t\tvar scaleLeft;\n\t\tvar scaleRight;\n\t\tvar floatLine;\n\t\tvar tooltip;\n\n\t\tvar line = function line(x, y) {\n\t\t\tif (!floatLine) {\n\t\t\t\tfloatLine = paper.path(createPathString({\n\t\t\t\t\tx: px(x),\n\t\t\t\t\ty: px(0)\n\t\t\t\t}, {\n\t\t\t\t\tx: px(x),\n\t\t\t\t\ty: px(y)\n\t\t\t\t})).attr({\n\t\t\t\t\tstroke: STROKE_COLOR\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfloatLine.attr({\n\t\t\t\tpath: createPathString({\n\t\t\t\t\tx: px(x),\n\t\t\t\t\ty: px(0)\n\t\t\t\t}, {\n\t\t\t\t\tx: px(x),\n\t\t\t\t\ty: px(y)\n\t\t\t\t}),\n\t\t\t\tstroke: '#aeaeae'\n\t\t\t});\n\t\t};\n\n\t\telem.on('mouseenter', function (e) {\n\t\t\tif (scaleLeft === undefined) {\n\t\t\t\tscaleLeft = scaleLinear().domain([0, _this4.offset]).rangeRound([0, _this4.shadowXList.length - 1]);\n\n\t\t\t\tif (_this4.predictXList) {\n\t\t\t\t\tscaleRight = scaleLinear().domain([_this4.offset, _this4.width]).rangeRound([0, _this4.predictXList.length - 1]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tooltip === undefined) {\n\t\t\t\ttooltip = _this4.createTooltip();\n\n\t\t\t\t_this4.eventLayer.append(tooltip);\n\t\t\t}\n\t\t}).on('mousemove', function (e) {\n\t\t\tif (_this4.shadowXList === undefined) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar x = e.pageX - offset.left;\n\t\t\tvar item;\n\t\t\tvar top;\n\n\t\t\tif (x < _this4.offset) {\n\t\t\t\tvar index = scaleLeft(x);\n\t\t\t\tvar x = _this4.shadowXList[index];\n\n\t\t\t\tif (x === undefined) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tline(x, _this4.needVolume ? _this4.chartHeight : _this4.height);\n\n\t\t\t\titem = _this4.candleData[index];\n\t\t\t\ttop = _this4.closeYList[index];\n\n\t\t\t\ttooltip.html(_this4.getTooltipHtml(item, 'normal'));\n\t\t\t} else {\n\t\t\t\tif (_this4.predictXList === undefined) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar index = scaleRight(x);\n\n\t\t\t\tif (index === 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (index >= _this4.predictXList.length) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar x = _this4.predictXList[index];\n\n\t\t\t\tline(x, _this4.needVolume ? _this4.chartHeight : _this4.height);\n\t\t\t\titem = _this4.predictData[index];\n\t\t\t\ttop = _this4.predictCloseYList[index];\n\n\t\t\t\ttooltip.html(_this4.getTooltipHtml(item, 'predict'));\n\t\t\t}\n\n\t\t\t// console.log(x, this.width, tooltip.width())\n\n\t\t\tif (x >= _this4.width - tooltip.width()) {\n\t\t\t\ttooltip.css({\n\t\t\t\t\t'top': top,\n\t\t\t\t\t'left': '',\n\t\t\t\t\t'right': layerWidth - _this4.width + 5\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\ttooltip.css({\n\t\t\t\t\t'top': top,\n\t\t\t\t\t'left': x + 5,\n\t\t\t\t\t'right': ''\n\t\t\t\t});\n\t\t\t}\n\t\t}).on('mouseleave', function (e) {\n\t\t\tscaleLeft = undefined;\n\t\t\tscaleRight = undefined;\n\t\t\tfloatLine = undefined;\n\t\t\tpaper.clear();\n\t\t\ttooltip.remove();\n\t\t\ttooltip = undefined;\n\t\t});\n\n\t\tthis.eventLayer = elem;\n\t},\n\n\thideCandleSet: function hideCandleSet() {\n\t\tif (this.candleSet) {\n\t\t\tthis.candleSet.hide();\n\t\t}\n\t},\n\n\tshowCandleSet: function showCandleSet() {\n\t\tthis.candleSet.show();\n\t},\n\n\thidePolySet: function hidePolySet() {\n\t\tif (this.polySet) {\n\t\t\tthis.polySet.hide();\n\t\t}\n\t},\n\n\tshowPolySet: function showPolySet() {\n\t\tthis.polySet.show();\n\t},\n\t// 收盘价折线\n\tdrawPolyline: function drawPolyline() {\n\t\tvar _this5 = this;\n\n\t\tthis.paper.setStart();\n\n\t\tvar points = this.candleData.map(function (item, i, arr) {\n\t\t\tvar x = _this5.shadowXList[i];\n\t\t\tvar y = _this5.candleY(_this5.candleData[i].close);\n\n\t\t\tif (i === 0) {\n\t\t\t\tx = 0;\n\t\t\t} else if (i === arr.length - 1) {\n\t\t\t\tx = _this5.offset;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tx: px(x),\n\t\t\t\ty: px(y)\n\t\t\t};\n\t\t});\n\n\t\tthis.paper.path(createPathString.apply(undefined, _toConsumableArray(points))).attr({\n\t\t\tstroke: '#297cda',\n\t\t\t'stroke-width': 2\n\t\t});\n\n\t\tthis.polySet = this.paper.setFinish();\n\t},\n\tclear: function clear() {\n\t\tthis.candleSet && this.candleSet.clear();\n\t\tthis.polySet && this.polySet.clear();\n\n\t\tif (this.eventLayer) {\n\t\t\tthis.eventLayer.off().remove();\n\t\t}\n\t\tthis.paper.clear();\n\t},\n\tupdate: function update(_ref) {\n\t\tvar candleData = _ref.candleData,\n\t\t    predictData = _ref.predictData,\n\t\t    cycle = _ref.cycle;\n\n\t\tthis.clear();\n\n\t\tif (candleData !== undefined) {\n\t\t\tthis.candleData = candleData.map(str2number);\n\t\t}\n\n\t\tif (predictData !== undefined) {\n\t\t\tthis.predictData = predictData.map(str2number);\n\t\t}\n\n\t\tif (cycle !== undefined) {\n\t\t\tthis.cycle = cycle;\n\t\t}\n\n\t\tthis.draw();\n\t}\n};\n\nmodule.exports = ChartPrototype;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/libs/ChartPrototype.js\n// module id = 7\n// module chunks = 0 1\n//# sourceURL=webpack:///./src/libs/ChartPrototype.js?")},function(module,exports){eval("'use strict';\n/* eslint-disable no-unused-vars */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (e) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (Object.getOwnPropertySymbols) {\n\t\t\tsymbols = Object.getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/object-assign/index.js\n// module id = 8\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/object-assign/index.js?")},function(module,exports){eval('module.exports = window.$;\n\n//////////////////\n// WEBPACK FOOTER\n// external "window.$"\n// module id = 9\n// module chunks = 0 1\n//# sourceURL=webpack:///external_%22window.$%22?')},function(module,exports){eval("'use strict';\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\n/**\r\n * Created by shinan on 2016/12/6.\r\n */\n\nvar UnitUtil = {\n  millionBillion: function millionBillion(n) {\n    var a = [[1e4, '万'], [1e8, '亿']];\n\n    for (var i = a.length - 1; i >= 0; i--) {\n      var _a$i = _slicedToArray(a[i], 2),\n          size = _a$i[0],\n          unit = _a$i[1];\n\n      if (n > size) {\n        var ret = (n / size).toFixed(2);\n\n        if (i == 0) {\n          ret = parseInt(ret);\n        }\n\n        return ret + unit;\n      }\n    }\n\n    return n;\n  },\n  million: function million(n) {\n    var ret = parseInt(n / 1e4);\n\n    return ret + '\\u4E07';\n  }\n};\n\nmodule.exports = UnitUtil;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/libs/UnitUtil.js\n// module id = 10\n// module chunks = 0 1\n//# sourceURL=webpack:///./src/libs/UnitUtil.js?")}]);