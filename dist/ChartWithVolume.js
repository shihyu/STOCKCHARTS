var ChartWithVolume=function(t){function n(i){if(e[i])return e[i].exports;var a=e[i]={exports:{},id:i,loaded:!1};return t[i].call(a.exports,a,a.exports,n),a.loaded=!0,a.exports}var e={};return n.m=t,n.c=e,n.p="",n(0)}([function(module,exports,__webpack_require__){eval("const str2number = __webpack_require__(7);\nconst d3 = __webpack_require__(4);\nconst Raphel = __webpack_require__(3);\nconst {\n\tOUTTER_MARGIN,\n\tVOL_HEIGHT,\n\tBOTTOM_TEXT_HEIGHT,\n\tPIXEL_FIX,\n\tSTROKE_COLOR,\n\tFONT_SIZE,\n\tTEXT_COLOR\n} = __webpack_require__(1);\nconst px = __webpack_require__(6);\nconst createPathString = __webpack_require__(2);\nconst ChartPrototype = __webpack_require__(5);\n\nconst ChartWithVolume = function (container, {\n\tchartWidth,\n\tchartHeight,\n\tcandleData,\n\tneedVolume,\n\tticksY,\n\tcycle,\n\ttooltip\n}) {\n\tthis.container = container;\n\tthis.paper = new Raphel(container, chartWidth, chartHeight);\n\tthis.chartWidth = chartWidth;\n\tthis.chartHeight = chartHeight;\n\n\tthis.candleData = candleData.map(str2number);\n\tthis.needVolume = needVolume || false;\n\tthis.ticksY = ticksY || 4;\n\tthis.cycle = cycle;\n\n\tthis.options = {\n\t\ttooltip: tooltip\n\t};\n};\n\nChartWithVolume.prototype = {\n\tdraw: function () {\n\t\tvar volHeight = this.needVolume ? VOL_HEIGHT : 0;\n\t\tvar { candleData } = this;\n\n\t\tvar low = candleData.reduce((prev, curr) => {\n\t\t\tif (curr.low < prev) {\n\t\t\t\treturn curr.low;\n\t\t\t}\n\n\t\t\treturn prev;\n\t\t}, candleData[0].low);\n\n\t\tvar high = candleData.reduce((prev, curr) => {\n\t\t\tif (curr.high > prev) {\n\t\t\t\treturn curr.high;\n\t\t\t}\n\n\t\t\treturn prev;\n\t\t}, candleData[0].high);\n\n\t\tthis.low = low;\n\t\tthis.high = high;\n\n\t\tthis.width = this.chartWidth - 40; // 总宽度减y轴文字宽度\n\t\tthis.height = this.chartHeight - volHeight - FONT_SIZE - BOTTOM_TEXT_HEIGHT; // 总高度减量柱高度减x轴文字高度减底部标注高度\n\n\t\tthis.paper.rect(0, 0, this.width, this.height).attr({\n\t\t\tstroke: STROKE_COLOR\n\t\t});\n\n\t\tvar total = candleData.length;\n\t\t// var predictPercent = (total - this.cycle) / total\n\n\t\t// console.log('predictPercent:', predictPercent)\n\n\t\t// predictPercent = predictPercent.toFixed(2)\n\n\t\tvar predictPercent = 0.7;\n\n\t\t// 预测部分图形的偏移量\n\t\tthis.offset = this.width * predictPercent;\n\n\t\tvar yScale = d3.scaleLinear().domain([0, this.ticksY - 1]).rangeRound([0, this.height]);\n\n\t\t// 预测部分半透明虚框\n\t\tvar pathString = createPathString({\n\t\t\tx: this.offset,\n\t\t\ty: 0\n\t\t}, {\n\t\t\tx: this.width,\n\t\t\ty: 0\n\t\t}, {\n\t\t\tx: this.width,\n\t\t\ty: this.height + volHeight + FONT_SIZE\n\t\t}, {\n\t\t\tx: this.offset,\n\t\t\ty: this.height + volHeight + FONT_SIZE\n\t\t}, {\n\t\t\tx: this.offset,\n\t\t\ty: 0\n\t\t});\n\n\t\tthis.paper.path(pathString).attr({\n\t\t\t'fill': '#f5f9fd',\n\t\t\t'stroke-width': 1,\n\t\t\t'fill-opacity': 0.5,\n\t\t\t'stroke': '#79c0ff'\n\t\t});\n\n\t\t// x轴信息\n\t\tvar dates = [candleData[0].time, candleData[candleData.length - this.cycle].time, candleData[candleData.length - 1].time];\n\n\t\t// console.log(dates)\n\n\t\tdates = dates.map(v => {\n\n\t\t\tvar d = new Date(v),\n\t\t\t    month = '' + (d.getMonth() + 1),\n\t\t\t    day = '' + d.getDate(),\n\t\t\t    year = d.getFullYear();\n\n\t\t\tif (month.length < 2) month = '0' + month;\n\t\t\tif (day.length < 2) day = '0' + day;\n\n\t\t\treturn [year, month, day].join('-');\n\t\t});\n\n\t\t// console.log(dates)\n\n\t\tdates.forEach((item, index, arr) => {\n\t\t\tvar elem = this.paper.text(0, 0, item).attr('fill', '#999');\n\t\t\tvar box = elem.getBBox();\n\t\t\tvar { width, height } = box;\n\n\t\t\tvar x,\n\t\t\t    y = this.height + height / 2 + (FONT_SIZE - height) / 2;\n\n\t\t\tif (index === 0) {\n\t\t\t\tx = 0 + width / 2;\n\t\t\t} else if (index === 1) {\n\t\t\t\tx = this.offset - width / 2;\n\t\t\t} else {\n\t\t\t\tx = this.width - width / 2;\n\t\t\t}\n\n\t\t\telem.attr({\n\t\t\t\tx: x,\n\t\t\t\ty: y\n\t\t\t});\n\t\t});\n\n\t\t// K线横向辅助线\n\t\tthis.drawHelperLines(yScale);\n\t\tthis.drawCandles(this.width);\n\n\t\t// 绘制量柱\n\t\tif (this.needVolume) {\n\t\t\tthis.drawVolumes();\n\t\t}\n\n\t\tthis.drawCycleBlock();\n\t\t// 事件\n\t\tif (this.options.tooltip) {\n\t\t\tthis.createEventLayerNormal();\n\t\t}\n\t},\n\tdrawCycleBlock: function () {\n\t\tconsole.log('drawCycleBlock fire');\n\t\t// 后续走势标注\n\t\tthis.paper.path(createPathString({\n\t\t\tx: this.offset,\n\t\t\ty: this.chartHeight - BOTTOM_TEXT_HEIGHT\n\t\t}, {\n\t\t\tx: this.offset,\n\t\t\ty: this.chartHeight\n\t\t})).attr({\n\t\t\tstroke: TEXT_COLOR\n\t\t});\n\n\t\tthis.paper.path(createPathString({\n\t\t\tx: this.width,\n\t\t\ty: this.chartHeight - BOTTOM_TEXT_HEIGHT\n\t\t}, {\n\t\t\tx: this.width,\n\t\t\ty: this.chartHeight\n\t\t})).attr({\n\t\t\tstroke: TEXT_COLOR\n\t\t});\n\n\t\t// 后续走势\n\t\tvar txt = this.paper.text(this.offset, this.chartHeight - BOTTOM_TEXT_HEIGHT, '后续走势').attr('fill', '#0287fe');\n\n\t\tvar box = txt.getBBox();\n\t\tvar { width, height } = box;\n\t\tvar x = (this.width - this.offset) / 2 + this.offset;\n\t\tvar y = this.chartHeight - BOTTOM_TEXT_HEIGHT + height / 2 + (BOTTOM_TEXT_HEIGHT - height) / 2;\n\n\t\ttxt.attr({\n\t\t\tx: x,\n\t\t\ty: y\n\t\t});\n\n\t\t// |-\n\t\tthis.paper.path(createPathString({\n\t\t\tx: this.offset,\n\t\t\ty: this.chartHeight - BOTTOM_TEXT_HEIGHT / 2\n\t\t}, {\n\t\t\tx: x - width / 2,\n\t\t\ty: this.chartHeight - BOTTOM_TEXT_HEIGHT / 2\n\t\t})).attr({\n\t\t\tstroke: '#0287fe'\n\t\t});\n\n\t\t// -|\n\t\tthis.paper.path(createPathString({\n\t\t\tx: this.width,\n\t\t\ty: this.chartHeight - BOTTOM_TEXT_HEIGHT / 2\n\t\t}, {\n\t\t\tx: x + width / 2,\n\t\t\ty: this.chartHeight - BOTTOM_TEXT_HEIGHT / 2\n\t\t})).attr({\n\t\t\tstroke: '#0287fe'\n\t\t});\n\t}\n};\n\nObject.assign(ChartWithVolume.prototype, ChartPrototype);\n\nmodule.exports = ChartWithVolume;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ChartWithVolume.js\n// module id = 0\n// module chunks = 1\n//# sourceURL=webpack:///./src/ChartWithVolume.js?")},function(module,exports){eval("const MARGIN_TABLE = {\n\t10: 4,\n\t20: 3,\n\t40: 1,\n\t60: 1\n};\n\nconst PIXEL_FIX = 0.5;\nconst OUTTER_MARGIN = 2;\nconst VOL_HEIGHT = 66;\nconst FONT_SIZE = 20;\nconst WIN_COLOR = '#e63232';\nconst LOSS_COLOR = '#55a500';\nconst STROKE_COLOR = '#d8d8d8';\nconst DASH_COLOR = '#999999';\nconst BOTTOM_TEXT_HEIGHT = 20;\nconst TEXT_COLOR = '#0287fe';\n\nmodule.exports = {\n\tMARGIN_TABLE,\n\tOUTTER_MARGIN,\n\tVOL_HEIGHT,\n\tFONT_SIZE,\n\tPIXEL_FIX,\n\tWIN_COLOR,\n\tLOSS_COLOR,\n\tSTROKE_COLOR,\n\tDASH_COLOR,\n\tBOTTOM_TEXT_HEIGHT,\n\tTEXT_COLOR\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/libs/config.js\n// module id = 1\n// module chunks = 0 1\n//# sourceURL=webpack:///./src/libs/config.js?")},function(module,exports){eval("var createPathString = function (...points) {\n\tvar pathString = `M${ points[0].x },${ points[0].y }`;\n\n\tfor (var i = 1; i < points.length; i++) {\n\t\tpathString += `L${ points[i].x },${ points[i].y }`;\n\t}\n\n\treturn pathString;\n};\n\nmodule.exports = createPathString;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/libs/createPathString.js\n// module id = 2\n// module chunks = 0 1\n//# sourceURL=webpack:///./src/libs/createPathString.js?")},function(module,exports){eval('module.exports = window.Raphael;\n\n//////////////////\n// WEBPACK FOOTER\n// external "window.Raphael"\n// module id = 3\n// module chunks = 0 1\n//# sourceURL=webpack:///external_%22window.Raphael%22?')},function(module,exports){eval('module.exports = window.d3;\n\n//////////////////\n// WEBPACK FOOTER\n// external "window.d3"\n// module id = 4\n// module chunks = 0 1\n//# sourceURL=webpack:///external_%22window.d3%22?')},function(module,exports,__webpack_require__){eval("const d3 = __webpack_require__(4);\nconst $ = __webpack_require__(8);\nconst Raphel = __webpack_require__(3);\nconst {\n\tMARGIN_TABLE,\n\tCANDLE_WIDTH,\n\tOUTTER_MARGIN,\n\tVOL_HEIGHT,\n\tFONT_SIZE,\n\tSTROKE_COLOR,\n\tWIN_COLOR,\n\tLOSS_COLOR,\n\tPIXEL_FIX\n} = __webpack_require__(1);\n\nconst px = function (value) {\n\tvalue = Math.floor(value);\n\treturn value + PIXEL_FIX;\n};\n\nconst createPathString = __webpack_require__(2);\n\nmodule.exports = {\n\tdrawHelperLines: function (yScale) {\n\t\t// K线横向辅助线\n\t\tfor (var i = 1; i < this.ticksY - 1; i++) {\n\t\t\tlet x1 = px(0);\n\t\t\tlet y1 = px(this.height - yScale(i));\n\t\t\tlet x2 = px(this.width);\n\t\t\tlet y2 = px(this.height - yScale(i));\n\n\t\t\t// console.log(x1, y1, x2, y2)\n\n\t\t\tlet pathString = createPathString({ x: x1, y: y1 }, { x: x2, y: y2 });\n\n\t\t\tthis.paper.path(pathString).attr({\n\t\t\t\tstroke: STROKE_COLOR\n\t\t\t});\n\t\t}\n\t},\n\tdrawCandles: function (baseWidth) {\n\t\tvar round = Math.round;\n\t\tvar { candleData, predictData, low, high } = this;\n\t\tvar scaleY = d3.scaleLinear().domain([low, high]).rangeRound([this.height, 0]);\n\t\tvar totalWidth = baseWidth - OUTTER_MARGIN * 2;\n\t\tvar count = candleData.length;\n\t\tvar candleWidth = 2 * totalWidth / (3 * count - 1);\n\t\tvar candleSpace = candleWidth / 2;\n\n\t\tif (candleSpace < 1) {\n\t\t\tcandleSpace = 0;\n\t\t\tcandleWidth = totalWidth / count;\n\t\t}\n\n\t\t// console.log('candleWidth, candleSpace', candleWidth, candleSpace)\n\n\t\tthis.shadowXList = [];\n\t\tthis.paper.setStart();\n\n\t\tcandleData.forEach((item, index) => {\n\t\t\tlet { open, close, low, high } = item;\n\t\t\tlet x = OUTTER_MARGIN + round(index * (candleWidth + candleSpace));\n\t\t\tlet y1, y2, color, height;\n\n\t\t\tif (open > close) {\n\t\t\t\ty1 = scaleY(open);\n\t\t\t\ty2 = scaleY(close);\n\n\t\t\t\tcolor = LOSS_COLOR;\n\t\t\t} else {\n\t\t\t\ty1 = scaleY(close);\n\t\t\t\ty2 = scaleY(open);\n\n\t\t\t\tcolor = WIN_COLOR;\n\t\t\t}\n\n\t\t\theight = Math.abs(y1 - y2);\n\n\t\t\t// console.log('蜡烛块信息:', px(x), px(y1), candleWidth, height)\n\n\t\t\t// 实体块\n\t\t\tthis.paper.rect(x, y1, candleWidth, height).attr({\n\t\t\t\t'fill': color,\n\t\t\t\t'stroke-width': 0\n\t\t\t});\n\n\t\t\t// 上下影线\n\t\t\tvar shadowX = px(x + round(candleWidth / 2));\n\t\t\tvar pathString = createPathString({\n\t\t\t\tx: shadowX,\n\t\t\t\ty: px(scaleY(high))\n\t\t\t}, {\n\t\t\t\tx: shadowX,\n\t\t\t\ty: px(scaleY(low))\n\t\t\t});\n\n\t\t\tthis.shadowXList.push(shadowX);\n\t\t\tthis.paper.path(pathString).attr('stroke', color);\n\t\t});\n\n\t\tthis.candleWidth = candleWidth;\n\t\tthis.candleSpace = candleSpace;\n\t\tthis.candleY = scaleY;\n\n\t\tthis.candleSet = this.paper.setFinish();\n\t},\n\tdrawVolumes: function () {\n\t\tvar round = Math.round;\n\t\t// 量线，绘制量柱\n\t\tvar volX = 0;\n\t\tvar volY = this.height + FONT_SIZE; // 加文字高度\n\t\tvar volWidth = this.width;\n\t\tvar volHeight = VOL_HEIGHT;\n\t\tvar candleData = this.candleData;\n\n\t\tvar { candleWidth, candleSpace } = this;\n\t\t// 量图边框\n\t\tthis.paper.rect(px(volX), px(volY), volWidth, volHeight - 1).attr('stroke', STROKE_COLOR);\n\n\t\tvar maxVol = candleData.reduce((prev, curr) => {\n\t\t\tif (curr.volume > prev) {\n\t\t\t\treturn curr.volume;\n\t\t\t}\n\n\t\t\treturn prev;\n\t\t}, candleData[0].volume);\n\n\t\tvar volLinear = d3.scaleLinear().domain([0, maxVol]).rangeRound([0, volHeight]);\n\n\t\t// 量柱横向辅助线\n\t\tvar p1 = {\n\t\t\tx: px(0),\n\t\t\ty: px(this.height + FONT_SIZE + (volHeight >> 1))\n\t\t};\n\n\t\tvar p2 = {\n\t\t\tx: px(this.width),\n\t\t\ty: px(this.height + FONT_SIZE + (volHeight >> 1))\n\t\t};\n\n\t\tthis.paper.path(createPathString(p1, p2)).attr({\n\t\t\tstroke: STROKE_COLOR\n\t\t});\n\n\t\t// 量柱\n\t\tcandleData.forEach((item, index, arr) => {\n\t\t\tlet x = OUTTER_MARGIN + round(index * (candleWidth + candleSpace));\n\t\t\tlet h = volLinear(item.volume);\n\t\t\tlet y = this.height + FONT_SIZE + volHeight - h;\n\t\t\tlet { open, close } = item;\n\t\t\tlet color;\n\n\t\t\tif (open > close) {\n\t\t\t\tcolor = '#55a500';\n\t\t\t} else {\n\t\t\t\tcolor = '#e63232';\n\t\t\t}\n\n\t\t\tthis.paper.rect(x, y, candleWidth, h).attr({\n\t\t\t\tfill: color,\n\t\t\t\t'stroke-width': 0\n\t\t\t});\n\t\t});\n\t},\n\tcreateEventLayerNormal: function () {\n\t\tvar elem = $('<div>').css({\n\t\t\tposition: 'absolute',\n\t\t\tleft: 0,\n\t\t\ttop: 0,\n\t\t\twidth: this.chartWidth,\n\t\t\theight: this.chartHeight\n\t\t});\n\n\t\t$(this.container).css({\n\t\t\tposition: 'relative'\n\t\t}).append(elem);\n\n\t\tvar offset = elem.offset();\n\t\tvar paper = new Raphel(elem[0], this.chartWidth, this.chartHeight);\n\t\tvar scaleLeft;\n\t\tvar floatLine;\n\t\tvar tooltip;\n\n\t\tvar line = (x, y) => {\n\t\t\tif (!floatLine) {\n\t\t\t\tfloatLine = paper.path(createPathString({\n\t\t\t\t\tx: px(x),\n\t\t\t\t\ty: px(0)\n\t\t\t\t}, {\n\t\t\t\t\tx: px(x),\n\t\t\t\t\ty: px(y)\n\t\t\t\t})).attr({\n\t\t\t\t\tstroke: STROKE_COLOR\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfloatLine.attr({\n\t\t\t\tpath: createPathString({\n\t\t\t\t\tx: px(x),\n\t\t\t\t\ty: px(0)\n\t\t\t\t}, {\n\t\t\t\t\tx: px(x),\n\t\t\t\t\ty: px(y)\n\t\t\t\t}),\n\t\t\t\tstroke: STROKE_COLOR\n\t\t\t});\n\t\t};\n\n\t\telem.on('mouseover', e => {\n\t\t\tscaleLeft = d3.scaleLinear().domain([0, this.width]).rangeRound([0, this.shadowXList.length - 1]);\n\n\t\t\ttooltip = $('<div>').css({\n\t\t\t\tposition: 'absolute',\n\t\t\t\ttop: 10\n\t\t\t});\n\n\t\t\tthis.eventLayer.append(tooltip);\n\t\t});\n\n\t\telem.on('mousemove', e => {\n\t\t\tif (this.shadowXList === undefined) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar x = e.pageX - offset.left;\n\t\t\tvar index = scaleLeft(x);\n\t\t\tvar x = this.shadowXList[index];\n\n\t\t\tif (x === undefined) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tline(x, this.needVolume ? this.height + FONT_SIZE + VOL_HEIGHT : this.height);\n\n\t\t\ttooltip.css('left', x + 5).html(this.options.tooltip.call(this, this.candleData[index]));\n\t\t});\n\n\t\telem.on('mouseout', e => {\n\t\t\tscaleLeft = undefined;\n\t\t\tfloatLine = undefined;\n\t\t\tpaper.clear();\n\t\t\ttooltip.remove();\n\t\t\ttooltip = undefined;\n\t\t});\n\n\t\tthis.eventLayer = elem;\n\t},\n\tcreateEventLayer: function () {\n\t\tvar elem = $('<div>').css({\n\t\t\tposition: 'absolute',\n\t\t\tleft: 0,\n\t\t\ttop: 0,\n\t\t\twidth: this.chartWidth,\n\t\t\theight: this.chartHeight\n\t\t});\n\n\t\t$(this.container).css({\n\t\t\tposition: 'relative'\n\t\t}).append(elem);\n\n\t\tvar offset = elem.offset();\n\t\tvar paper = new Raphel(elem[0], this.chartWidth, this.chartHeight);\n\t\tvar scaleLeft;\n\t\tvar scaleRight;\n\t\tvar floatLine;\n\t\tvar tooltip;\n\n\t\tvar line = (x, y) => {\n\t\t\tif (!floatLine) {\n\t\t\t\tfloatLine = paper.path(createPathString({\n\t\t\t\t\tx: px(x),\n\t\t\t\t\ty: px(0)\n\t\t\t\t}, {\n\t\t\t\t\tx: px(x),\n\t\t\t\t\ty: px(y)\n\t\t\t\t})).attr({\n\t\t\t\t\tstroke: STROKE_COLOR\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfloatLine.attr({\n\t\t\t\tpath: createPathString({\n\t\t\t\t\tx: px(x),\n\t\t\t\t\ty: px(0)\n\t\t\t\t}, {\n\t\t\t\t\tx: px(x),\n\t\t\t\t\ty: px(y)\n\t\t\t\t}),\n\t\t\t\tstroke: STROKE_COLOR\n\t\t\t});\n\t\t};\n\n\t\telem.on('mouseenter', e => {\n\t\t\tscaleLeft = d3.scaleLinear().domain([0, this.offset]).rangeRound([0, this.shadowXList.length - 1]);\n\n\t\t\tif (this.predictXList) {\n\t\t\t\tscaleRight = d3.scaleLinear().domain([this.offset, this.width]).rangeRound([0, this.predictXList.length - 1]);\n\t\t\t}\n\n\t\t\ttooltip = $('<div>').css({\n\t\t\t\tposition: 'absolute',\n\t\t\t\ttop: 10\n\t\t\t});\n\n\t\t\tthis.eventLayer.append(tooltip);\n\t\t});\n\n\t\telem.on('mousemove', e => {\n\t\t\tif (this.shadowXList === undefined) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar x = e.pageX - offset.left;\n\n\t\t\tif (x < this.offset) {\n\t\t\t\tvar index = scaleLeft(x);\n\t\t\t\tvar x = this.shadowXList[index];\n\n\t\t\t\tif (x === undefined) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tline(x, this.needVolume ? this.chartHeight : this.height);\n\n\t\t\t\ttooltip.css('left', x + 5).html(this.options.tooltip.call(this, this.candleData[index]));\n\t\t\t} else {\n\t\t\t\tif (this.predictXList === undefined) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar index = scaleRight(x);\n\t\t\t\tif (index === 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (index >= this.predictXList.length) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar x = this.predictXList[index];\n\t\t\t\tline(x, this.needVolume ? this.chartHeight : this.height);\n\n\t\t\t\ttooltip.css('left', x + 5).html(this.options.tooltip.call(this, this.predictData[index]));\n\t\t\t}\n\t\t});\n\n\t\telem.on('mouseleave', e => {\n\t\t\tscaleLeft = undefined;\n\t\t\tscaleRight = undefined;\n\t\t\tfloatLine = undefined;\n\t\t\tpaper.clear();\n\n\t\t\ttooltip.remove();\n\t\t\ttooltip = undefined;\n\t\t});\n\n\t\tthis.eventLayer = elem;\n\t},\n\n\thideCandleSet: function () {\n\t\tif (this.candleSet) {\n\t\t\tthis.candleSet.hide();\n\t\t}\n\t},\n\n\tshowCandleSet: function () {\n\t\tthis.candleSet.show();\n\t},\n\n\thidePolySet: function () {\n\t\tif (this.polySet) {\n\t\t\tthis.polySet.hide();\n\t\t}\n\t},\n\n\tshowPolySet: function () {\n\t\tif (!this.polySet) {\n\t\t\tthis.drawPolyline();\n\t\t}\n\n\t\tthis.polySet.show();\n\t},\n\t// 收盘价折线\n\tdrawPolyline: function () {\n\t\tvar p = this.paper;\n\n\t\tp.setStart();\n\n\t\tvar points = [];\n\t\tfor (var i = 0; i < this.candleData.length; i++) {\n\t\t\tvar x = this.shadowXList[i];\n\t\t\tvar y = this.candleY(this.candleData[i].close);\n\n\t\t\tpoints.push({\n\t\t\t\tx: px(x),\n\t\t\t\ty: px(y)\n\t\t\t});\n\t\t}\n\n\t\tvar pathString = createPathString(...points);\n\n\t\tp.path(pathString).attr({\n\t\t\tstroke: '#999'\n\t\t});\n\n\t\tthis.polySet = p.setFinish();\n\t\tthis.polySet.hide();\n\t},\n\tclear: function () {\n\t\tthis.paper.clear();\n\t},\n\tupdate: function ({ candleData, predictData, cycle }) {\n\t\tthis.clear();\n\n\t\tif (candleData !== undefined) {\n\t\t\tthis.candleData = candleData.map(str2number);\n\t\t}\n\n\t\tif (predictData !== undefined) {\n\t\t\tthis.predictData = predictData.map(str2number);\n\t\t}\n\n\t\tif (cycle !== undefined) {\n\t\t\tthis.cycle = cycle;\n\t\t}\n\n\t\tthis.draw();\n\t}\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/libs/ChartPrototype.js\n// module id = 5\n// module chunks = 0 1\n//# sourceURL=webpack:///./src/libs/ChartPrototype.js?")},function(module,exports){eval("const pixelFix = 0.5;\n\nconst px = function (value) {\n\tvalue = Math.floor(value);\n\treturn value + pixelFix;\n};\n\nmodule.exports = px;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/libs/px.js\n// module id = 6\n// module chunks = 0 1\n//# sourceURL=webpack:///./src/libs/px.js?")},function(module,exports){eval("module.exports = function (stock) {\n\tvar keys = ['low', 'high', 'open', 'close'];\n\n\tkeys.forEach(function (key) {\n\t\tstock[key] = Number(stock[key]);\n\t});\n\n\treturn stock;\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/libs/str2number.js\n// module id = 7\n// module chunks = 0 1\n//# sourceURL=webpack:///./src/libs/str2number.js?")},function(module,exports){eval('module.exports = window.$;\n\n//////////////////\n// WEBPACK FOOTER\n// external "window.$"\n// module id = 8\n// module chunks = 0 1\n//# sourceURL=webpack:///external_%22window.$%22?')}]);